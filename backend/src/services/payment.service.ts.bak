```typescript
// src/services/payment.service.ts
import { PrismaClient } from '@prisma/client';
import { calculateInstallmentStatus } from '../utils/paymentHelpers';

const prisma = new PrismaClient();

/**
 * Create Payment Plan for an enrollment
 */
export const createPaymentPlan = async (data: {
  enrollmentId: string;
  totalAmount: number;
  discountAmount?: number;
  discountReason?: string;
  totalInstallments: number;
  installments: {
    installmentNumber: number;
    amount: number;
    paymentDate: string; // Due date
  }[];
}) => {
  // Check enrollment exists
  const enrollment = await prisma.enrollment.findUnique({
    where: { id: data.enrollmentId },
  });

  if (!enrollment) {
    throw new Error('Enrollment not found');
  }

  // Check if payment plan already exists
  const existing = await prisma.studentPaymentPlan.findUnique({
    where: { enrollmentId: data.enrollmentId },
  });

  if (existing) {
    throw new Error('Payment plan already exists for this enrollment');
  }

  const finalAmount = data.totalAmount - (data.discountAmount || 0);

  // Create plan + installments in transaction
  const result = await prisma.$transaction(async (tx) => {
    const plan = await tx.studentPaymentPlan.create({
      data: {
        enrollmentId: data.enrollmentId,
        totalAmount: data.totalAmount,
        discountAmount: data.discountAmount || 0,
        discountReason: data.discountReason,
        finalAmount: finalAmount,
        totalInstallments: data.totalInstallments,
        status: 'ACTIVE',
      },
    });

    // Create installments
    for (const inst of data.installments) {
      await tx.installment.create({
        data: {
          paymentPlanId: plan.id,
          installmentNumber: inst.installmentNumber,
          amount: inst.amount,
          paymentDate: new Date(inst.paymentDate),
          paymentMethod: 'PENDING', // Will be updated when paid
        },
      });
    }

    return tx.studentPaymentPlan.findUnique({
      where: { id: plan.id },
      include: {
        installments: { orderBy: { installmentNumber: 'asc' } },
        enrollment: {
          include: {
            student: true,
            group: { include: { term: true, level: true } },
          },
        },
      },
    });
  });

  return result;
};

/**
 * Get Payment Plan by Enrollment ID
 */
export const getPaymentPlanByEnrollment = async (enrollmentId: string) => {
  const plan = await prisma.studentPaymentPlan.findUnique({
    where: { enrollmentId },
    include: {
      installments: { orderBy: { installmentNumber: 'asc' } },
      enrollment: {
        include: {
          student: true,
          group: { include: { term: true, level: true } },
        },
      },
    },
  });

  if (!plan) {
    throw new Error('Payment plan not found');
  }

  // Add calculated status to each installment
  const planWithStatus = {
    ...plan,
    installments: plan.installments.map(inst => ({
      ...inst,
      status: calculateInstallmentStatus(inst)
    }))
  };

  return planWithStatus;
};

/**
 * Get all payment plans with filters
 */
export const getAllPaymentPlans = async (filters: {
  status?: string;
  termId?: string;
  page?: number;
  limit?: number;
}) => {
  const page = filters.page || 1;
  const limit = filters.limit || 50;
  const skip = (page - 1) * limit;

  const where: any = {};
  if (filters.status) where.status = filters.status;
  if (filters.termId) {
    where.enrollment = { group: { termId: filters.termId } };
  }

  const [plans, total] = await Promise.all([
    prisma.studentPaymentPlan.findMany({
      where,
      skip,
      take: limit,
      include: {
        installments: true,
        enrollment: {
          include: {
            student: true,
            group: { include: { term: true } },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.studentPaymentPlan.count({ where }),
  ]);

  return {
    data: plans,
    pagination: {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    },
  };
};

/**
 * Record a payment for an installment
 */
export const recordPayment = async (
  installmentId: string,
  data: {
    paymentMethod: string;
    receiptNumber?: string;
    receiptUrl?: string;
    receiptMakerId?: string;
    benefitReferenceNumber?: string;
    notes?: string;
  }
) => {
  const installment = await prisma.installment.findUnique({
    where: { id: installmentId },
    include: { paymentPlan: true },
  });

  if (!installment) {
    throw new Error('Installment not found');
  }

  // ✅ CHECK: Prevent recording payment if already paid
  // A payment is considered paid if it has a paymentDate (not null)
  if (installment.paymentDate) {
    throw new Error(
      'Installment already paid. Use update endpoint to modify payment details.'
    );
  }

  // Update installment
  const updated = await prisma.installment.update({
    where: { id: installmentId },
    data: {
      paymentMethod: data.paymentMethod,
      paymentDate: new Date(), // Set payment date to now
      receiptNumber: data.receiptNumber,
      receiptUrl: data.receiptUrl,
      receiptMakerId: data.receiptMakerId,
      benefitReferenceNumber: data.benefitReferenceNumber,
      notes: data.notes,
    },
    include: {
      paymentPlan: {
        include: {
          installments: true,
          enrollment: { include: { student: true } },
        },
      },
    },
  });

  // Check if all installments paid → mark plan as COMPLETED
  // An installment is paid if it has a paymentDate
  const allPaid = updated.paymentPlan.installments.every(
    (i) => i.paymentDate !== null
  );

  if (allPaid) {
    await prisma.studentPaymentPlan.update({
      where: { id: updated.paymentPlan.id },
      data: { status: 'COMPLETED' },
    });
  }

  return updated;
};

/**
 * Update existing payment record
 */
export const updatePayment = async (
  installmentId: string,
  data: {
    paymentMethod?: string;
    receiptNumber?: string;
    receiptUrl?: string;
    benefitReferenceNumber?: string;
    notes?: string;
  }
) => {
  const installment = await prisma.installment.findUnique({
    where: { id: installmentId },
  });

  if (!installment) {
    throw new Error('Installment not found');
  }

  // ✅ CHECK: Must already be paid to update
  // A payment is paid if it has a paymentDate
  if (!installment.paymentDate) {
    throw new Error('Cannot update unpaid installment. Record payment first.');
  }

  return await prisma.installment.update({
    where: { id: installmentId },
    data,
    include: {
      paymentPlan: {
        include: {
          installments: true,
          enrollment: { include: { student: true } },
        },
      },
    },
  });
};

/**
 * Get balance for a payment plan
 */
export const getBalance = async (enrollmentId: string) => {
  const plan = await prisma.studentPaymentPlan.findUnique({
    where: { enrollmentId },
    include: { installments: true },
  });

  if (!plan) {
    throw new Error('Payment plan not found');
  }

  const totalPaid = plan.installments
    .filter((i) => i.paymentDate !== null)
    .reduce((sum, i) => sum + Number(i.amount), 0);

  const balance = Number(plan.finalAmount) - totalPaid;

  const paidInstallments = plan.installments.filter(
    (i) => i.paymentDate !== null
  ).length;

  const remainingInstallments = plan.totalInstallments - paidInstallments;

  // Find next unpaid installment
  const nextUnpaid = plan.installments
    .filter((i) => i.paymentDate === null)
    .sort((a, b) => a.installmentNumber - b.installmentNumber)[0];

  return {
    totalAmount: Number(plan.totalAmount),
    discountAmount: Number(plan.discountAmount),
    finalAmount: Number(plan.finalAmount),
    totalPaid,
    balance,
    totalInstallments: plan.totalInstallments,
    paidInstallments,
    remainingInstallments,
    nextDueDate: nextUnpaid?.paymentDate || null,
    nextDueAmount: nextUnpaid ? Number(nextUnpaid.amount) : 0,
  };
};

/**
 * Create refund request
 */
export const createRefund = async (data: {
  installmentId?: string;
  enrollmentId: string;
  refundAmount: number;
  refundReason: string;
  refundMethod?: string;
  requestedBy: string; // userId
  notes?: string;
}) => {
  // Verify enrollment exists
  const enrollment = await prisma.enrollment.findUnique({
    where: { id: data.enrollmentId },
  });

  if (!enrollment) {
    throw new Error('Enrollment not found');
  }

  const refund = await prisma.refund.create({
    data: {
      installmentId: data.installmentId,
      enrollmentId: data.enrollmentId,
      refundAmount: data.refundAmount,
      refundReason: data.refundReason,
      refundMethod: data.refundMethod,
      requestedBy: data.requestedBy,
      status: 'PENDING',
      notes: data.notes,
    },
    include: {
      installment: true,
      enrollment: { include: { student: true } },
      requester: true,
    },
  });

  return refund;
};

/**
 * Approve refund
 */
export const approveRefund = async (refundId: string, approvedBy: string) => {
  const refund = await prisma.refund.findUnique({ where: { id: refundId } });

  if (!refund) {
    throw new Error('Refund not found');
  }

  if (refund.status !== 'PENDING') {
    throw new Error('Refund already processed');
  }

  return await prisma.refund.update({
    where: { id: refundId },
    data: {
      status: 'APPROVED',
      approvedBy,
      approvedAt: new Date(),
    },
    include: {
      enrollment: { include: { student: true } },
    },
  });
};

/**
 * Process refund (mark as completed)
 */
export const processRefund = async (
  refundId: string,
  processedBy: string,
  receiptUrl?: string
) => {
  const refund = await prisma.refund.findUnique({ where: { id: refundId } });

  if (!refund) {
    throw new Error('Refund not found');
  }

  if (refund.status !== 'APPROVED') {
    throw new Error('Refund must be approved first');
  }

  return await prisma.refund.update({
    where: { id: refundId },
    data: {
      status: 'COMPLETED',
      processedBy,
      processedAt: new Date(),
      receiptUrl,
    },
  });
};

/**
 * Get all refunds
 */
export const getAllRefunds = async (filters: {
  status?: string;
  enrollmentId?: string;
  page?: number;
  limit?: number;
}) => {
  const page = filters.page || 1;
  const limit = filters.limit || 50;
  const skip = (page - 1) * limit;

  const where: any = {};
  if (filters.status) where.status = filters.status;
  if (filters.enrollmentId) where.enrollmentId = filters.enrollmentId;

  const [refunds, total] = await Promise.all([
    prisma.refund.findMany({
      where,
      skip,
      take: limit,
      include: {
        installment: true,
        enrollment: { include: { student: true } },
        requester: true,
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.refund.count({ where }),
  ]);

  return {
    data: refunds,
    pagination: {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    },
  };
};

// stripe 
export const getInstallmentWithStudent = async (installmentId: string) => {
  const installment = await prisma.installment.findUnique({
    where: { id: installmentId },
    include: {
      paymentPlan: {
        include: {
          enrollment: {
            include: { student: { include: { user: true } } }
          }
        }
      }
    }
  });

  if (!installment) {
    throw new Error('Installment not found');
  }

  return installment;
};